<!DOCTYPE html>

<html>
<head>
  <title>Setup</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="custom.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="raytracer.html">
                raytracer.js
              </a>
            
              
              <a class="source" href="vector.html">
                vector.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Setup</h1>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> c = document.getElementById(<span class="string">'c'</span>),
    width = <span class="number">640</span>,
    height = <span class="number">480</span>;

c.width = width;
c.height = height;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Get a context in order to generate a proper data array. We aren&#39;t going to
use traditional Canvas drawing functions like <code>fillRect</code> - instead this
raytracer will directly compute pixel data and then put it into an image.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>),
    data = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, width, height);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1>Lights</h1>
<p>Lights are defined only as points in space - surfaces that have lambert
shading will be affected by any visible lights.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> lights = [{ x: -<span class="number">30</span>, y: -<span class="number">10</span>, z: <span class="number">20</span> }];</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h1>Objects</h1>
<p>This raytracer handles sphere objects, with any color, position, radius,
and surface properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> objects = [{
    type: <span class="string">'sphere'</span>,
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">5</span>,
        z: -<span class="number">5</span>
    },
    color: {
        x: <span class="number">255</span>,
        y: <span class="number">255</span>,
        z: <span class="number">255</span>
    },
    specular: <span class="number">0.2</span>,
    radius: <span class="number">2</span>
}];</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h1>The Camera</h1>
<p>Our camera is pretty simple: it&#39;s a point in space, where you can imagine
that the camera &#39;sits&#39;, a <code>fieldOfView</code>, which is the angle from the right
to the left side of its frame, and a <code>vector</code> which determines what
angle it points in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> camera = {
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">1.8</span>,
        z: <span class="number">10</span>
    },
    fieldOfView: <span class="number">45</span>,
    vector: {
        x: <span class="number">0</span>,
        y: <span class="number">3</span>,
        z: <span class="number">0</span>
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h1>Throwing Rays</h1>
<p>For each pixel in the canvas, there needs to be at least one ray of light
that determines its color by bouncing through the scene.</p>
<p>This process
is a bit odd, because there&#39;s a disconnect between pixels and vectors:
given the left and right, top and bottom rays, the rays we shoot are just
interpolated between them in little increments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> eyeVector = Vector.unitVector(Vector.subtract(camera.vector, camera.point)),
    fovRadians = Math.PI * (camera.fieldOfView / <span class="number">2</span>) / <span class="number">180</span>,
    halfWidth = Math.tan(fovRadians),
    halfHeight = (height/width) * halfWidth,
    camerawidth = halfWidth * <span class="number">2</span>,
    cameraheight = halfHeight * <span class="number">2</span>,
    pixelWidth = camerawidth / (width - <span class="number">1</span>),
    pixelHeight = cameraheight / (height - <span class="number">1</span>),
    vpRight = Vector.unitVector(Vector.crossProduct(eyeVector, Vector.UP)),
    vpUp = Vector.unitVector(Vector.crossProduct(vpRight, eyeVector));

console.time(<span class="string">'render'</span>);
<span class="keyword">var</span> index, color;
<span class="keyword">var</span> ray = {
    point: camera.point
};
<span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; width; x++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; height; y++) {

        <span class="keyword">var</span> xcomp = Vector.scale(vpRight, (x * pixelWidth) - halfWidth),
            ycomp = Vector.scale(vpUp, (y * pixelHeight) - halfHeight);

        ray.vector = Vector.unitVector(Vector.add3(eyeVector, xcomp, ycomp));

        color = trace(ray, <span class="number">0</span>);
        index = (x * <span class="number">4</span>) + (y * width * <span class="number">4</span>),
        data.data[index + <span class="number">0</span>] = color.x;
        data.data[index + <span class="number">1</span>] = color.y;
        data.data[index + <span class="number">2</span>] = color.z;
        data.data[index + <span class="number">3</span>] = <span class="number">255</span>;
    }
}
console.timeEnd(<span class="string">'render'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Now that each ray has returned and populated the <code>data</code> array with
correctly lit colors, fill the canvas with the generated data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ctx.putImageData(data, <span class="number">0</span>, <span class="number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2>Sphere Intersection</h2>
<p>Spheres are one of the simplest objects for rays to interact with, since
the geometrical math for finding intersections and reflections with them
is pretty straightforward.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereIntersection</span><span class="params">(sphere, ray)</span> {</span>

    <span class="keyword">var</span> eye_to_center = Vector.subtract(sphere.point, ray.point),</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>the length of a
hypoteneuse of a right triangle with points
at the eye and the center of the circle, and a right
angle at the other point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        v = Vector.dotProduct(eye_to_center, ray.vector),
        eoDot = Vector.dotProduct(eye_to_center, eye_to_center),
        discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v);

    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) {
        <span class="keyword">return</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> v - Math.sqrt(discriminant);
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">sphereNormal</span><span class="params">(sphere, pos)</span> {</span>
    <span class="keyword">return</span> Vector.unitVector(
        Vector.subtract(pos, sphere.point));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h1>Tracing Rays to Objects</h1>
<p>Given a ray, let&#39;s figure out whether it hits anything, and if so,
what&#39;s the closest thing it hits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">intersectScene</span><span class="params">(ray)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The base case is that it hits nothing, and travels for <code>Infinity</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> closest = [<span class="literal">Infinity</span>, <span class="literal">null</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>But for each object, we check whether it has any intersection,
and compare that intersection - is it closer than <code>Infinity</code> at first,
and then is it closer than other objects that have been hit?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) {
        <span class="keyword">var</span> object = objects[i],
            dist = sphereIntersection(object, ray);
        <span class="keyword">if</span> (dist !== <span class="literal">undefined</span> &amp;&amp; dist &lt; closest[<span class="number">0</span>]) {
            closest = [dist, object];
        }
    }
    <span class="keyword">return</span> closest;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Given a ray, shoot it until it hits an object and return that object&#39;s color,
or <code>Vector.WHITE</code> if no object is found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(ray, depth)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>This is a recursive method: if we hit something that&#39;s reflective,
then the call to <code>surface()</code> at the bottom will return here and try
to find what the ray reflected into. Since this could easily go
on forever, first check that we haven&#39;t gone more than three bounces
into a reflection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) <span class="keyword">return</span>;

    <span class="keyword">var</span> distObject = intersectScene(ray);

    <span class="keyword">if</span> (distObject[<span class="number">0</span>] === <span class="literal">Infinity</span>) {
        <span class="keyword">return</span> Vector.WHITE;
    }

    <span class="keyword">var</span> dist = distObject[<span class="number">0</span>],
        object = distObject[<span class="number">1</span>];

    <span class="keyword">var</span> pointAtTime = Vector.add(ray.point, Vector.scale(ray.vector, dist));

    <span class="keyword">return</span> surface(ray, object, pointAtTime, sphereNormal(object, pointAtTime), depth);
}

<span class="function"><span class="keyword">function</span> <span class="title">isLightVisible</span><span class="params">(pt, light)</span> {</span>
    <span class="keyword">return</span> intersectScene({
        point: pt,
        vector: Vector.unitVector(Vector.subtract(pt, light))
    })[<span class="number">1</span>] !== <span class="literal">null</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h1>Surface</h1>
<p>The <code>trace()</code> function has figured out that something is hit by an ray,
and we&#39;re going to figure out what surface that thing has - what color
it&#39;ll send back to the camera.</p>
<p>Objects have different sorts of surfaces:</p>
<p><strong>Ambient</strong> colors shine bright regardless of whether there&#39;s a light visible -
a circle with a totally ambient blue color will always just be a flat blue
circle.</p>
<p><strong><a href="http://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert shading</a></strong>
is our pretty shading, which shows gradations from the most lit point on
the object to the least.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Specular_reflection">Specular</a></strong> is a fancy word for &#39;reflective&#39;: rays that hit objects
with specular surfaces bounce off and acquire the colors of other objects
they bounce into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">surface</span><span class="params">(ray, object, pointAtTime, normal, depth)</span> {</span>
    <span class="keyword">var</span> b = object.color,
        c = Vector.ZERO,
        lambertCoefficient = <span class="number">0.8</span>,
        reflectance = object.specular,
        ambient = Math.max(<span class="number">1</span> - reflectance - lambertCoefficient, <span class="number">0</span>),
        lambertAmount = <span class="number">0</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lights.length; i++) {
        <span class="keyword">var</span> lightPoint = lights[<span class="number">0</span>];
        <span class="keyword">if</span> (!isLightVisible(pointAtTime, lightPoint)) <span class="keyword">continue</span>;
        <span class="keyword">var</span> contribution = Vector.dotProduct(Vector.unitVector(
            Vector.subtract(lightPoint, pointAtTime)), normal);
        <span class="keyword">if</span> (contribution &gt; <span class="number">0</span>) lambertAmount += contribution;
    }

    <span class="keyword">if</span> (object.specular) {
        <span class="keyword">var</span> reflectedRay = {
            point: pointAtTime,
            vector: Vector.reflectThrough(ray.vector, normal)
        };
        <span class="keyword">var</span> reflectedColor = trace(reflectedRay, ++depth);
        <span class="keyword">if</span> (reflectedColor) {
            c = Vector.add(c, Vector.scale(reflectedColor, object.specular));
        }
    }

    lambertAmount = Math.min(<span class="number">1</span>, lambertAmount);

    <span class="keyword">return</span> Vector.add3(c,
        Vector.scale(b, lambertCoefficient * lambertAmount),
        Vector.scale(b, ambient));
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
