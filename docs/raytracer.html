<!DOCTYPE html>

<html>
<head>
  <title>Setup</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="raytracer.html">
                raytracer.js
              </a>
            
              
              <a class="source" href="vector.html">
                vector.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Setup</h1>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> c = document.getElementById(<span class="string">'c'</span>),
    width = <span class="number">640</span>,
    height = <span class="number">480</span>;

c.width = width;
c.height = height;

<span class="keyword">var</span> intersection = {
    sphere: sphereIntersection
};</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Get a context in order to generate a proper data array. We aren&#39;t going to
use traditional Canvas drawing functions like <code>fillRect</code> - instead this
raytracer will directly compute pixel data and then put it into an image.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>),
    data = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, width, height);

<span class="keyword">var</span> lights = [{ x: -<span class="number">30</span>, y: -<span class="number">10</span>, z: <span class="number">20</span> }];

<span class="keyword">var</span> objects = [];
<span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; <span class="number">1</span>; x++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; <span class="number">1</span>; y++) {
        <span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span>; z &lt; <span class="number">1</span>; z++) {
            objects.push({
                type: <span class="string">'sphere'</span>,
                point: {
                    x: x * <span class="number">3</span>,
                    y: <span class="number">5</span> + y * <span class="number">3</span>,
                    z: -<span class="number">5</span> + z * <span class="number">2</span>
                },
                color: {
                    x: <span class="number">255</span>,
                    y: <span class="number">255</span>,
                    z: <span class="number">255</span>
                },
                specular: <span class="number">0.2</span>, <span class="comment">// Math.random() &gt; 0.8 ? Math.random() : 0,</span>
                radius: <span class="number">3</span>
            });
        }
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">randomColor</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {
        x: Math.random() * <span class="number">255</span>,
        y: Math.random() * <span class="number">255</span>,
        z: Math.random() * <span class="number">255</span>
    };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Just like the objects, the camera is defined in 3D space: it&#39;s the combination
of a point where it &#39;is&#39;, a direction it&#39;s pointed - <code>vector</code> - and
<code>fieldOfView</code>, which is the angle from one side of its field of view
to the other.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> camera = {
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">1.8</span>,
        z: <span class="number">10</span>
    },
    fieldOfView: <span class="number">45</span>,
    vector: {
        x: <span class="number">0</span>,
        y: <span class="number">3</span>,
        z: <span class="number">0</span>
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h1>Throwing Rays</h1>
<p>For each pixel in the canvas, there needs to be at least one ray of light
that determines its color by bouncing through the scene.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> eyeVector = Vector.unitVector(Vector.subtract(camera.vector, camera.point)),
    fovRadians = Math.PI * (camera.fieldOfView / <span class="number">2</span>) / <span class="number">180</span>,
    halfWidth = Math.tan(fovRadians),
    halfHeight = (height/width) * halfWidth,
    camerawidth = halfWidth * <span class="number">2</span>,
    cameraheight = halfHeight * <span class="number">2</span>,
    pixelWidth = camerawidth / (width - <span class="number">1</span>),
    pixelHeight = cameraheight / (height - <span class="number">1</span>),
    vpRight = Vector.unitVector(Vector.crossProduct(eyeVector, Vector.UP)),
    vpUp = Vector.unitVector(Vector.crossProduct(vpRight, eyeVector));

<span class="keyword">var</span> index, ray, color;
<span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; width; x++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; height; y++) {

        <span class="keyword">var</span> xcomp = Vector.scale(vpRight, (x * pixelWidth) - halfWidth),
            ycomp = Vector.scale(vpUp, (y * pixelHeight) - halfHeight);

        ray = {
            point: camera.point,
            vector: Vector.unitVector(Vector.add(eyeVector, xcomp, ycomp))
        };

        color = trace(ray, <span class="number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Calculate the index into the pixel data array - each pixel
is represented by <code>[r, g, b, a]</code> in the array - and assign this pixel
a value we calculated by tracing a ray.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        index = (x * <span class="number">4</span>) + (y * width * <span class="number">4</span>),
        data.data[index + <span class="number">0</span>] = color.x;
        data.data[index + <span class="number">1</span>] = color.y;
        data.data[index + <span class="number">2</span>] = color.z;
        data.data[index + <span class="number">3</span>] = <span class="number">255</span>;
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Now that each ray has returned and populated the <code>data</code> array with
correctly lit colors, fill the canvas with the generated data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ctx.putImageData(data, <span class="number">0</span>, <span class="number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2>Sphere</h2>
<p>Spheres are one of the simplest objects for rays to interact with, since
the geometrical math for finding intersections and reflections with them
is pretty straightforward.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereIntersection</span><span class="params">(sphere, ray)</span> {</span>

    <span class="keyword">var</span> eye_to_center = Vector.subtract(sphere.point, ray.point),</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>the length of a
hypoteneuse of a right triangle with points
at the eye and the center of the circle, and a right
angle at the other point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        v = Vector.dotProduct(eye_to_center, ray.vector),
        eoDot = Vector.dotProduct(eye_to_center, eye_to_center),
        discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v);

    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) {
        <span class="keyword">return</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> v - Math.sqrt(discriminant);
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">sphereNormal</span><span class="params">(sphere, pos)</span> {</span>
    <span class="keyword">return</span> Vector.unitVector(
        Vector.subtract(pos, sphere.point));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>For a given ray, return the object that&#39;s closest to the camera and
the distance from the camera to that object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">intersectScene</span><span class="params">(ray)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>.reduce()</code> starts with <code>mem</code>, which is <code>[Infinity, null]</code>, and
compares each item to this value to see if it&#39;s closer to the camera
than infinity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> objects.reduce(<span class="keyword">function</span>(mem, object) {
        <span class="keyword">var</span> dist = intersection[object.type](object, ray);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>If no item is found, just return the existing <code>mem</code> value, since this
isn&#39;t the closest. Otherwise, it&#39;s the new closest and assign
it to <code>mem</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (dist === <span class="literal">undefined</span> || dist &gt; mem[<span class="number">0</span>]) <span class="keyword">return</span> mem;
        <span class="keyword">else</span> <span class="keyword">return</span> [dist, object];
    }, [<span class="literal">Infinity</span>, <span class="literal">null</span>]);
}

<span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(ray, depth)</span> {</span>
    <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) <span class="keyword">return</span>;

    <span class="keyword">var</span> distObject = intersectScene(ray);

    <span class="keyword">if</span> (distObject[<span class="number">0</span>] === <span class="literal">Infinity</span>) <span class="keyword">return</span> Vector.WHITE;

    <span class="keyword">var</span> dist = distObject[<span class="number">0</span>],
        object = distObject[<span class="number">1</span>],
        pointAtTime = Vector.add(ray.point, Vector.scale(ray.vector, dist));

    <span class="keyword">return</span> surface(ray, object, pointAtTime, sphereNormal(object, pointAtTime), depth);
}

<span class="function"><span class="keyword">function</span> <span class="title">visibleLight</span><span class="params">(pt)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(light) {
        <span class="keyword">return</span> intersectScene({
            point: pt,
            vector: Vector.unitVector(Vector.subtract(pt, light))
        })[<span class="number">1</span>] !== <span class="literal">null</span>;
    };
}

<span class="function"><span class="keyword">function</span> <span class="title">surface</span><span class="params">(ray, object, pointAtTime, normal, depth)</span> {</span>
    <span class="keyword">var</span> b = object.color,
        c = Vector.ZEROcp();
    <span class="keyword">var</span> lambertCoefficient = <span class="number">0.8</span>,
        reflectance = object.specular,
        ambient = Math.max(<span class="number">1</span> - reflectance - lambertCoefficient, <span class="number">0</span>);

    <span class="keyword">var</span> lambertAmount = <span class="number">0</span>;
    lights
        .filter(visibleLight(pointAtTime))
        .forEach(<span class="keyword">function</span>(lightPoint) {
            <span class="keyword">var</span> contribution = Vector.dotProduct(Vector.unitVector(
                Vector.subtract(lightPoint, pointAtTime)), normal);
            <span class="keyword">if</span> (contribution &gt; <span class="number">0</span>) lambertAmount += contribution;
        });

    <span class="keyword">if</span> (object.specular) {
        <span class="keyword">var</span> reflectedRay = {
            point: pointAtTime,
            vector: Vector.reflectThrough(ray.vector, normal)
        };
        <span class="keyword">var</span> reflectedColor = trace(reflectedRay, ++depth);
        <span class="keyword">if</span> (reflectedColor) {
            c = Vector.add(c, Vector.scale(reflectedColor, object.specular));
        }
    }

    lambertAmount = Math.min(<span class="number">1</span>, lambertAmount);
    c = Vector.add(c, Vector.scale(b, lambertCoefficient * lambertAmount));

    c = Vector.add(c, Vector.scale(b, ambient));
    <span class="keyword">return</span> c;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
