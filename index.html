<!DOCTYPE html>

<html>
<head>
  <title>Setup</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="custom.css" />
</head>
<body>
  <div id="container">
    <div class='cred'>
        <a href='https://github.com/tmcw/literate-raytracer'>an open source project by tom macwright</a>
    </div>
    <canvas id='c'></canvas>
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="vector.html">
                vector.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Setup</h1>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> c = document.getElementById(<span class="string">'c'</span>),
    width = <span class="number">640</span>,
    height = <span class="number">480</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Get a context in order to generate a proper data array. We aren&#39;t going to
use traditional Canvas drawing functions like <code>fillRect</code> - instead this
raytracer will directly compute pixel data and then put it into an image.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>c.width = width;
c.height = height;
<span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>),
    data = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, width, height);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1>The Scene</h1>
<p>We need to define three different kinds of things in 3D space:
a <strong>camera</strong> from which we cast rays into the scene, <strong>objects</strong>
that can be hit by those rays and are drawn into the scene, and
<strong>lights</strong> that change the color of rays, by extension coloring objects.</p>
<p>In this case, we define these objects as simple objects with vectors
defined as <code>{x, y, z}</code> objects.</p>
<h2>The Camera</h2>
<p>Our camera is pretty simple: it&#39;s a point in space, where you can imagine
that the camera &#39;sits&#39;, a <code>fieldOfView</code>, which is the angle from the right
to the left side of its frame, and a <code>vector</code> which determines what
angle it points in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> camera = {
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">1.8</span>,
        z: <span class="number">10</span>
    },
    fieldOfView: <span class="number">45</span>,
    vector: {
        x: <span class="number">0</span>,
        y: <span class="number">3</span>,
        z: <span class="number">0</span>
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2>Lights</h2>
<p>Lights are defined only as points in space - surfaces that have lambert
shading will be affected by any visible lights.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> lights = [{
    x: -<span class="number">30</span>,
    y: -<span class="number">10</span>,
    z: <span class="number">20</span>
}];</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2>Objects</h2>
<p>This raytracer handles sphere objects, with any color, position, radius,
and surface properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> objects = [{
    type: <span class="string">'sphere'</span>,
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">3.5</span>,
        z: -<span class="number">5</span>
    },
    color: {
        x: <span class="number">255</span>,
        y: <span class="number">255</span>,
        z: <span class="number">255</span>
    },
    specular: <span class="number">0.2</span>,
    radius: <span class="number">3</span>
}];</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h1>Throwing Rays</h1>
<p>For each pixel in the canvas, there needs to be at least one ray of light
that determines its color by bouncing through the scene.</p>
<p>This process
is a bit odd, because there&#39;s a disconnect between pixels and vectors:
given the left and right, top and bottom rays, the rays we shoot are just
interpolated between them in little increments.</p>
<p>Starting with the height and width of the scene, the camera&#39;s place,
direction, and field of view, we calculate factors that create
<code>width*height</code> vectors for each ray</p>
<p>Start by creating a simple vector pointing in the direction the camera is
pointing - a unit vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> eyeVector = Vector.unitVector(Vector.subtract(camera.vector, camera.point)),</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>and then we&#39;ll rotate this by combining it with a version that&#39;s turned
90° right and one that&#39;s turned 90° up. Since the <a href="http://en.wikipedia.org/wiki/Cross_product">cross product</a>
takes two vectors and creates a third that&#39;s perpendicular to both,
we use a pure &#39;UP&#39; vector to turn the camera right, and that &#39;right&#39;
vector to turn the camera up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    vpRight = Vector.unitVector(Vector.crossProduct(eyeVector, Vector.UP)),
    vpUp = Vector.unitVector(Vector.crossProduct(vpRight, eyeVector)),</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The actual ending pixel dimensions of the image aren&#39;t important here -
note that <code>width</code> and <code>height</code> are in pixels, but the numbers we compute
here are just based on the ratio between them, <code>height/width</code>, and the
<code>fieldOfView</code> of the camera.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fovRadians = Math.PI * (camera.fieldOfView / <span class="number">2</span>) / <span class="number">180</span>,
    heightWidthRatio = height / width,
    halfWidth = Math.tan(fovRadians),
    halfHeight = heightWidthRatio * halfWidth,
    camerawidth = halfWidth * <span class="number">2</span>,
    cameraheight = halfHeight * <span class="number">2</span>,
    pixelWidth = camerawidth / (width - <span class="number">1</span>),
    pixelHeight = cameraheight / (height - <span class="number">1</span>);

console.time(<span class="string">'render'</span>);
<span class="keyword">var</span> index, color;
<span class="keyword">var</span> ray = {
    point: camera.point
};
<span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; width; x++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; height; y++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>turn the raw pixel <code>x</code> and <code>y</code> values into values from -1 to 1
and use these values to scale the facing-right and facing-up
vectors so that we generate versions of the <code>eyeVector</code> that are
skewed in each necessary direction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> xcomp = Vector.scale(vpRight, (x * pixelWidth) - halfWidth),
            ycomp = Vector.scale(vpUp, (y * pixelHeight) - halfHeight);

        ray.vector = Vector.unitVector(Vector.add3(eyeVector, xcomp, ycomp));</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>use the vector generated to raytrace the scene, returning a color
as a <code>{x, y, z}</code> vector of RGB values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        color = trace(ray, <span class="number">0</span>);
        index = (x * <span class="number">4</span>) + (y * width * <span class="number">4</span>),
        data.data[index + <span class="number">0</span>] = color.x;
        data.data[index + <span class="number">1</span>] = color.y;
        data.data[index + <span class="number">2</span>] = color.z;
        data.data[index + <span class="number">3</span>] = <span class="number">255</span>;
    }
}
console.timeEnd(<span class="string">'render'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Now that each ray has returned and populated the <code>data</code> array with
correctly lit colors, fill the canvas with the generated data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ctx.putImageData(data, <span class="number">0</span>, <span class="number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2>Sphere Intersection</h2>
<p><img src="graphics/sphereintersection.png" alt=""></p>
<p>Spheres are one of the simplest objects for rays to interact with, since
the geometrical math for finding intersections and reflections with them
is pretty straightforward.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereIntersection</span><span class="params">(sphere, ray)</span> {</span>
    <span class="keyword">var</span> eye_to_center = Vector.subtract(sphere.point, ray.point),</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>picture a triangle with one side going straight from the camera point
to the center of the sphere, another side being the vector.
the final side is a right angle.</p>
<p>This equation first figures out the length of the vector side</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        v = Vector.dotProduct(eye_to_center, ray.vector),</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>then the length of the straight from the camera to the center
of the sphere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        eoDot = Vector.dotProduct(eye_to_center, eye_to_center),</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>and compute a segment from the right angle of the triangle to a point
on the <code>v</code> line that also intersects the circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If the discriminant is negative, that means that the sphere hasn&#39;t
been hit by the ray</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) {
        <span class="keyword">return</span>;
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>otherwise, we return the distance from the camera point to the sphere
<code>Math.sqrt(dotProduct(a, a))</code> is the length of a vector, so
<code>v - Math.sqrt(discriminant)</code> means the length of the the vector
just from the camera to the intersection point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> v - Math.sqrt(discriminant);
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>A normal is, at each point on the surface of a sphere or some other object,
a vector that&#39;s perpendicular to the surface and radiates outward. We need
to know this so that we can calculate the way that a ray reflects off of
a sphere.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereNormal</span><span class="params">(sphere, pos)</span> {</span>
    <span class="keyword">return</span> Vector.unitVector(
        Vector.subtract(pos, sphere.point));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h1>Tracing Rays to Objects</h1>
<p>Given a ray, let&#39;s figure out whether it hits anything, and if so,
what&#39;s the closest thing it hits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">intersectScene</span><span class="params">(ray)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>The base case is that it hits nothing, and travels for <code>Infinity</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> closest = [<span class="literal">Infinity</span>, <span class="literal">null</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>But for each object, we check whether it has any intersection,
and compare that intersection - is it closer than <code>Infinity</code> at first,
and then is it closer than other objects that have been hit?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) {
        <span class="keyword">var</span> object = objects[i],
            dist = sphereIntersection(object, ray);
        <span class="keyword">if</span> (dist !== <span class="literal">undefined</span> &amp;&amp; dist &lt; closest[<span class="number">0</span>]) {
            closest = [dist, object];
        }
    }
    <span class="keyword">return</span> closest;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Given a ray, shoot it until it hits an object and return that object&#39;s color,
or <code>Vector.WHITE</code> if no object is found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(ray, depth)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>This is a recursive method: if we hit something that&#39;s reflective,
then the call to <code>surface()</code> at the bottom will return here and try
to find what the ray reflected into. Since this could easily go
on forever, first check that we haven&#39;t gone more than three bounces
into a reflection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) <span class="keyword">return</span>;

    <span class="keyword">var</span> distObject = intersectScene(ray);</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>If we don&#39;t hit anything, fill this pixel with the background color -
in this case, white.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (distObject[<span class="number">0</span>] === <span class="literal">Infinity</span>) {
        <span class="keyword">return</span> Vector.WHITE;
    }

    <span class="keyword">var</span> dist = distObject[<span class="number">0</span>],
        object = distObject[<span class="number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The <code>pointAtTime</code> is another way of saying the &#39;intersection point&#39;
of this ray into this object. We compute this by simply taking
the direction of the ray and making it as long as the distance
returned by the intersection check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> pointAtTime = Vector.add(ray.point, Vector.scale(ray.vector, dist));

    <span class="keyword">return</span> surface(ray, object, pointAtTime, sphereNormal(object, pointAtTime), depth);
}

<span class="function"><span class="keyword">function</span> <span class="title">isLightVisible</span><span class="params">(pt, light)</span> {</span>
    <span class="keyword">return</span> intersectScene({
        point: pt,
        vector: Vector.unitVector(Vector.subtract(pt, light))
    })[<span class="number">1</span>] !== <span class="literal">null</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h1>Surface</h1>
<p>The <code>trace()</code> function has figured out that something is hit by an ray,
and we&#39;re going to figure out what surface that thing has - what color
it&#39;ll send back to the camera.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">surface</span><span class="params">(ray, object, pointAtTime, normal, depth)</span> {</span>
    <span class="keyword">var</span> b = object.color,
        c = Vector.ZERO,
        lambertCoefficient = <span class="number">0.8</span>,
        reflectance = object.specular,
        ambient = Math.max(<span class="number">1</span> - reflectance - lambertCoefficient, <span class="number">0</span>),
        lambertAmount = <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><strong><a href="http://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert shading</a></strong>
is our pretty shading, which shows gradations from the most lit point on
the object to the least.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lights.length; i++) {
        <span class="keyword">var</span> lightPoint = lights[<span class="number">0</span>];
        <span class="keyword">if</span> (!isLightVisible(pointAtTime, lightPoint)) <span class="keyword">continue</span>;
        <span class="keyword">var</span> contribution = Vector.dotProduct(Vector.unitVector(
            Vector.subtract(lightPoint, pointAtTime)), normal);
        <span class="keyword">if</span> (contribution &gt; <span class="number">0</span>) lambertAmount += contribution;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><strong><a href="https://en.wikipedia.org/wiki/Specular_reflection">Specular</a></strong> is a fancy word for &#39;reflective&#39;: rays that hit objects
with specular surfaces bounce off and acquire the colors of other objects
they bounce into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (object.specular) {
        <span class="keyword">var</span> reflectedRay = {
            point: pointAtTime,
            vector: Vector.reflectThrough(ray.vector, normal)
        };
        <span class="keyword">var</span> reflectedColor = trace(reflectedRay, ++depth);
        <span class="keyword">if</span> (reflectedColor) {
            c = Vector.add(c, Vector.scale(reflectedColor, object.specular));
        }
    }

    lambertAmount = Math.min(<span class="number">1</span>, lambertAmount);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><strong>Ambient</strong> colors shine bright regardless of whether there&#39;s a light visible -
a circle with a totally ambient blue color will always just be a flat blue
circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> Vector.add3(c,
        Vector.scale(b, lambertCoefficient * lambertAmount),
        Vector.scale(b, ambient));
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <script src='vector.js'></script>
  <script src='index.js'></script>
</body>
</html>
